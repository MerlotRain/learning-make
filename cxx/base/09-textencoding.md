# 字符串编码问题

在Windows的C++开发中，字符串编码经常是一个老大难的问题，尤其是读写的文件的时候，总是会出现各种乱码，让人很搞不清楚。

## 一、C++标准字符串类

`C++`标准库提供了两个常用的字符串类，`std::string`和`std::wstring`。

我们分别开查看这两个类的作用。

### 1.1 `std::string`和`std::wstring`的定义

`std::string`在标准库中的定义如下

```c++

using string  = basic_string<char, char_traits<char>, allocator<char>>;	
using wstring = basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;

```
可以看出，`std::string`是一个`char`的序列，也就是单字节字符串，每个字节的范围就是`char`的范围。而`std::wstring`是`wchar_t`的序列，这是两者的本质区别。

我们知道，`wchar_t`在不同的平台下长度不同，在`Windows`下，它的长度是`16`，在`Mac OSX`或`Linux`下，它的长度是`32`。

所以我们只能称`wchar_t`是多字节字符串。

### 1.2 `std::wstring`的编码

与`std::string`不同，`std::wstring`是有明确的编码的，在`Windows`平台，它的编码方式是`UTF-16`，因为`wchar_t`的长度就是16，所以自然而然采用了`UTF-16`的编码。

但在`Mac OSX`或`Linux`，它则表示为`UTF-32`的编码，也是固定的。

不过这个类在非`Windows`平台下使用很少，因为确实没必要，其他类`UNIX`平台完全可以用`UTF-8`编码的`std::string`.

### 1.3 `std::string`的编码

`std::string`有确定的编码吗？

答案是没有。

因为前面也说了，`std::string`只是一个字符串序列，它只是保存了一串字符，除此之外并不具备任何意义，它的一切API也都是字符序列的。

那我们常说的字符编码到底是什么，为什么其他语言都会说自己是`Unicode`编码，`UTF-8`编码。

## 二、字符编码

我们知道计算机中的数据都是以二进制存储的，所以需要将数据转换为对应的二进制，在使用的时候从二进制转到真实的我们可以辨识的数据。

计算机最早在美国诞生，结合美国的实际情况，他们只需要一个`char`范围的数据即可表示所有的字符，包括大小写英文字母，标点符号等等符号。

但是随着计算机推广，到了西欧，再到东欧等等国家。

`char`，这个255量级的字符已经不够用了，于是很多国家就开始了自己的字符集。

以中国为例，中国便将最常用的汉字编写成了`GB2312`这样的字符集。

但是我们也都明白，英文的ASCII码终究还是重要非凡，所以其他国家在创建自己的字符集的时候，都兼容了ASCII码，然后在此基础上扩展，他们通常使用两个字节，也就是一个`short`的长度进行表示。

可以说，这个长度对大部分国家来讲也是够了。

之后出现的三字节等等的我们不去讨论了。

字符编码越来越多，于是就出现了`Unicode`这样一个万国码。

### 2.1 `Unicode`

`Unicode`凭什么被称为万国码？

首先需要声明的是，`Unicode`提供的是一个码值，它使用`21`位的长度来表示各个国家的字符，总数共计111万多，目前已经使用了20多万，所以可以明确的是：

**`Unicode`**目前几十年内是用不完的。

它本质是提供了一个表，这个表记录了每个码值对应的字符，而且确保唯一不重复。

### 2.2 `Unicode`怎么编码

上述中我们知道，`Unicode`使用的是`21`位这个不上不下的值，所以在表示的时候就出现了很多分歧。

最粗暴的解决方案是使用`32位`表示，这样不管什么字符都不会超过这个范围，简单好用。

但带来的问题也很明显，最常用的英文只需要`8位`，这样起始造成了`24位`的浪费。

第二种解决方案是`16位`，也就是`UTF-16`,虽然这个范围比`21`小，但起始涵盖了大部分，甚至是绝大部分的常用的字符，而且也有其他技术手段来用解决其他字符的表示，这里不展开。

这种方式比上一种的开销就小了很多，虽然也没有解决英文的问题，但是总比上述方式好用。

第三种解决方案是`8位`，也就是`UTF-8`。

它的策略是，一个字符需要几位我就用几位，比如英文就是用`8位`，中文就使用`24位`。物尽其用，做到了最好的存储优化。

而也是现代计算机最推崇的方式，也是更加标准的方式。

### 2.3 `Unicode`实现

通过上述的内容，你也可以明白，无论是什么编码，我们都可以将它看成是一串`char`的集合，唯一的问题是，我们读`char`集合的时候，怎么打断它。

对于纯英文来说，完全不用打断，但是对其他文字来说，可能需要两字节两字节地读，也可能需要三字节三字节地读，非常麻烦，那有什么好办法吗？

起始就是上面提到的`UTF-16`和`UTF-32`。

它们确切的以两字节或四字节读取，非常方便。

这也是`QString`的实现，使用`UTF-16`的编码处理。

## 三、`std::string`的编码

通过上面两部分，我们就知道了，`std::string`起始没有固定的编码，它只是字符序列，怎么读需要开发人员来决定，怎么写也是如此，甚至需要多方的约定。

搞定出这一点，我们就需要知道这个约定到底从何而来。

### 3.1 字符串编译

我们看下面这段代码，当我们在Windows下使用VS开发时，这个字符串到底是什么编码方式。

```C++

int main()
{
	std::string str1 = "你好世界";
}

```

答案是`GB2312`（zh_CN）。

* 为什么会这样？

回答这个问题，我们首先需要知道编译的原理和两个编码。

* 编码一：源码编码

源码编码就是我们的`cpp`文件的编码，`Visual Studio 20XX`通常采用系统默认的编码，例如`GB2312`，`Visual Studio Codo`则采用`UTF-8`作为文件编码。

我们写完代码之后保存文件后，字符串`str1`的`你好世界`就以文件的编码保存到了硬盘上。

* 编码二：编译编码

当我们开始编译的时候，编译器首先根据文件的编码读取这个信息，例如读取到`GB2312`格式的`你好世界`，然后它需要将这段代码编译成数据段的数据，使用的编码格式，默认则是我们操作系统的格式，也就是`GB2312`。

所以这段代码在Windows下编译的结果是`GB2312`编码的数据段。

但是在其他平台则是`UTF-8`的数据段。

当看到这里，你马上会发现问题，这样的操作不就无法跨平台了吗？

的确，这种方式导致了不同平台下的行为异常，这几乎是无法避免的。

### 3.2 字面量

为了解决上面的问题，C++标准委员会引入了字符串字面量类型的后缀。它们主要影响字符常量的类型，以便更精确地控制字符集和编码方式。

#### 1. `L`后缀

* 用于指定 wchar_t 类型的字符字面量。

* 适用于宽字符，通常用于表示 Unicode 字符集（至少是 UTF-16 或 UTF-32 编码），根据平台的实现不同。

* 示例：

```C++
wchar_t ch = L'a'; // L 表示 wchar_t 类型
```

#### 2. `u`后缀

* 用于指定 char16_t 类型的字符字面量，通常表示 UTF-16 编码。

* 示例：

```C++
char16_t ch = u'a'; // u 表示 char16_t 类型，UTF-16 编码
```

#### 3. `u8`后缀

* 用于指定 char 类型的字符串字面量，表示 UTF-8 编码的字符序列。

* u8 后缀通常用于 UTF-8 编码的字符串。

* 示例：

```C++
const char* str = u8"Hello, World!"; // u8 表示 UTF-8 编码的字符串
```

#### 4. `U`后缀

* 用于指定 char32_t 类型的字符字面量，通常表示 UTF-32 编码。

* 示例：

```C++
char32_t ch = U'a'; // U 表示 char32_t 类型，UTF-32 编码
```

#### 总结：

* `L`：`wchar_t`（宽字符），通常表示 UTF-16 或平台特定的编码。

* `u`：`char16_t`（UTF-16 字符串）。

* `u8`：`char`（UTF-8 字符串）。

* `U`：`char32_t`（UTF-32 字符）。
